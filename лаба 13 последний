import tkinter as tk
from tkinter import messagebox
import random

class MazeGame:
    def init(self, root, cols=21, rows=15, cell_size=32, time_limit_sec=60):
        self.root = root
        self.root.title("Паук в лабиринте — Авто DFS")
        self.cols = cols if cols % 2 == 1 else cols + 1
        self.rows = rows if rows % 2 == 1 else rows + 1
        self.cell_size = cell_size
        self.time_limit = time_limit_sec
        self.remaining = time_limit_sec
        self.game_over = False
        self.running_dfs = False

        self.canvas_width = self.cols * self.cell_size
        self.canvas_height = self.rows * self.cell_size

        top = tk.Frame(root)
        top.pack(side=tk.TOP, fill=tk.X)
        self.timer_label = tk.Label(top, text="", font=("Segoe UI", 14))
        self.timer_label.pack(side=tk.LEFT, padx=8, pady=6)

        self.reset_btn = tk.Button(top, text="Новая игра", command=self.reset_game)
        self.reset_btn.pack(side=tk.LEFT, padx=6)
        self.start_btn = tk.Button(top, text="Запустить DFS", command=self.start_dfs)
        self.start_btn.pack(side=tk.LEFT, padx=6)

        self.canvas = tk.Canvas(root, width=self.canvas_width, height=self.canvas_height, bg="#111")
        self.canvas.pack()

        self.walls = None
        self.player = (1, 1)
        self.exit_cell = (self.cols - 2, self.rows - 2)
        self.player_item = None
        self.exit_item = None

        self.reset_game()
        self.tick_timer()

    # Лабиринт и отрисовка
    def reset_game(self):
        if self.running_dfs:
            return
        self.game_over = False
        self.remaining = self.time_limit
        self.player = (1, 1)
        self.exit_cell = (self.cols - 2, self.rows - 2)
        self.generate_maze()
        self.draw_maze()
        self.draw_exit()
        self.draw_player()
        self.canvas.delete("dfs_vis")
        self.update_timer_label()

    def generate_maze(self):
        self.walls = [[[True, True, True, True] for _ in range(self.cols)] for _ in range(self.rows)]
        visited = [[False for _ in range(self.cols)] for _ in range(self.rows)]

        def neighbors(cx, cy):
            dirs = [("N", (0, -2), 0, 2), ("S", (0, 2), 2, 0), ("W", (-2, 0), 3, 1), ("E", (2, 0), 1, 3)]
            random.shuffle(dirs)
            for _, (dx, dy), wall_dir, opposite in dirs:
                nx, ny = cx + dx, cy + dy
                if 1 <= nx < self.cols - 1 and 1 <= ny < self.rows - 1 and not visited[ny][nx]:
                    yield nx, ny, dx, dy

        stack = [(1, 1)]
        visited[1][1] = True
        while stack:
            cx, cy = stack[-1]
            advanced = False
            for nx, ny, dx, dy in neighbors(cx, cy):
                wx, wy = cx + dx // 2, cy + dy // 2
                self.walls[wy][wx] = [False, False, False, False]
                if dy == -2:
                    self.walls[cy][cx][0] = False
                    self.walls[ny][nx][2] = False
                elif dy == 2:
                    self.walls[cy][cx][2] = False
                    self.walls[ny][nx][0] = False
                elif dx == -2:
                    self.walls[cy][cx][3] = False
                    self.walls[ny][nx][1] = False
                elif dx == 2:
                    self.walls[cy][cx][1] = False
                    self.walls[ny][nx][3] = False
                visited[ny][nx] = True
                stack.append((nx, ny))
                advanced = True
                break
            if not advanced:
                stack.pop()

        for x in range(self.cols):
            self.walls[0][x][0] = True
            self.walls[self.rows - 1][x][2] = True
        for y in range(self.rows):
            self.walls[y][0][3] = True
            self.walls[y][self.cols - 1][1] = True

        sx, sy = self.player
        ex, ey = self.exit_cell
        for d in range(4):
            self.walls[sy][sx][d] = False
            self.walls[ey][ex][d] = False 
def draw_maze(self):
        self.canvas.delete("all")
        self.canvas.create_rectangle(0, 0, self.canvas_width, self.canvas_height, fill="#111", outline="")
        wall_color = "#4c566a"
        for y in range(self.rows):
            for x in range(self.cols):
                cx, cy = x * self.cell_size, y * self.cell_size
                wN, wE, wS, wW = self.walls[y][x]
                if wN:
                    self.canvas.create_line(cx, cy, cx + self.cell_size, cy, fill=wall_color, width=2)
                if wE:
                    self.canvas.create_line(cx + self.cell_size, cy, cx + self.cell_size, cy + self.cell_size, fill=wall_color, width=2)
                if wS:
                    self.canvas.create_line(cx, cy + self.cell_size, cx + self.cell_size, cy + self.cell_size, fill=wall_color, width=2)
                if wW:
                    self.canvas.create_line(cx, cy, cx, cy + self.cell_size, fill=wall_color, width=2)

    def draw_player(self):
        if self.player_item:
            self.canvas.delete(self.player_item)
        x, y = self.player
        cx = x * self.cell_size + self.cell_size // 2
        cy = y * self.cell_size + self.cell_size // 2
        r = self.cell_size * 0.35
        self.player_item = self.canvas.create_oval(cx - r, cy - r, cx + r, cy + r, fill="#a3be8c", outline="#2e3440", width=2)

    def draw_exit(self):
        if self.exit_item:
            self.canvas.delete(self.exit_item)
        x, y = self.exit_cell
        cx = x * self.cell_size + self.cell_size // 2
        cy = y * self.cell_size + self.cell_size // 2
        s = self.cell_size * 0.6
        self.exit_item = self.canvas.create_rectangle(cx - s/2, cy - s/2, cx + s/2, cy + s/2, fill="#bf616a", outline="#2e3440", width=2)

    #  Таймер
    def tick_timer(self):
        if not self.game_over:
            self.remaining = max(0, self.remaining - 1)
            self.update_timer_label()
            if self.remaining == 0:
                self.end_game(False)
        self.root.after(1000, self.tick_timer)

    def update_timer_label(self):
        self.timer_label.config(text=f"Время: {self.remaining:02d} c")

    def end_game(self, win):
        if self.game_over:
            return
        self.game_over = True
        self.running_dfs = False
        title = "Победа!" if win else "Время вышло"
        text = "Паук нашёл выход!" if win else "Паук не успел выбраться..."
        messagebox.showinfo(title, text)

    #
    def _dfs_neighbors(self, x, y):
        # 0:N,1:E,2:S,3:W стены относительно клетки (x,y)
        deltas = [("N", 0, -1, 0), ("E", 1, 0, 1), ("S", 0, 1, 2), ("W", -1, 0, 3)]
        # Перемешаем порядок для разнообразия
        dirs = deltas[:]
        random.shuffle(dirs) # случайно
        for _, dx, dy, wall_idx in dirs: # Проверяет можно ли пройти в этом направлении
            nx, ny = x + dx, y + dy
            if 0 <= nx < self.cols and 0 <= ny < self.rows:
                if not self.walls[y][x][wall_idx]:
                    yield nx, ny

    def start_dfs(self):
        if self.running_dfs or self.game_over:
            return
        self.canvas.delete("dfs_vis")
        self.running_dfs = True
        self._run_dfs_step(
            stack=[self.player],  # Создаём стек с начальной позицией паука
            visited={self.player},
            parent={}
        )

    def _run_dfs_step(self, stack, visited, parent):
        if self.game_over or not self.running_dfs:
            return

        if not stack:
            # Не нашли выход — останавливаемся
            self.running_dfs = False
            return

        current = stack.pop() # БЕРЁМ ВЕРХНИЙ ЭЛЕМЕНТ СТЕКА

        # Обновляем позицию паука (делает "ход")
        self.player = current
        self.draw_player()

        # Отметим посещение
        cx = current[0] * self.cell_size + self.cell_size // 2
        cy = current[1] * self.cell_size + self.cell_size // 2
        r = self.cell_size * 0.16
        self.canvas.create_oval(cx - r, cy - r, cx + r, cy + r, fill="#5e81ac", outline="", tags="dfs_vis")
# Проверка на выход
        if current == self.exit_cell:
            # Подсветим найденный путь (по parent до старта)
            path = []
            node = current
            start = (1, 1)
            while node != start and node in parent:
                path.append(node)
                node = parent[node]
            path.append(start)
            path.reverse()
            self._draw_path(path)
            self.end_game(True)
            return

        # Добавляем соседей
        for nx, ny in self._dfs_neighbors(*current): # Проверяем соседей текущей клетки
            if (nx, ny) not in visited:
                visited.add((nx, ny))
                parent[(nx, ny)] = current # запоминает откуда пришли в новую клетку
                stack.append((nx, ny))

        # Продолжаем через небольшой интервал (анимация шагов)
        # Если время кончилось, end_game уже вызовется таймером
        speed_ms = 250
        self.root.after(speed_ms, lambda: self._run_dfs_step(stack, visited, parent))

    def _draw_path(self, path):
        pts = []
        for (x, y) in path:
            cx = x * self.cell_size + self.cell_size // 2
            cy = y * self.cell_size + self.cell_size // 2
            pts.append((cx, cy))
        for i in range(len(pts) - 1):
            x1, y1 = pts[i]
            x2, y2 = pts[i + 1]
            self.canvas.create_line(x1, y1, x2, y2, fill="#ebcb8b", width=4)
        for (cx, cy) in pts:
            r = self.cell_size * 0.12
            self.canvas.create_oval(cx - r, cy - r, cx + r, cy + r, fill="#d08770", outline="")

if name == "main":
    root = tk.Tk()
    game = MazeGame(root, cols=21, rows=15, cell_size=28, time_limit_sec=60)
    root.mainloop()
