import tkinter as tk
import random
import time

class SpiderMaze:
    def __init__(self, root):
        self.root = root
        self.root.title("Паук в лабиринте")

        # Параметры
        self.cols = 15
        self.rows = 15
        self.cell = 30

        # Создаем лабиринт
        self.create_maze()

        # Паук и выходы
        self.spider = (self.rows-2,self.cols-2)
        self.exits = [(1,1)]
        self.create_exits()

        # Для поиска
        self.visited = set([self.spider])
        self.queue = [self.spider]
        self.parent = {}
        self.running = False
        self.start_time = 0

        # Интерфейс
        self.canvas = tk.Canvas(root, width=self.cols*self.cell, height=self.rows*self.cell, bg='white')
        self.canvas.pack()

        # Кнопки
        tk.Button(root, text="Старт", command=self.start).pack(side=tk.LEFT)
        tk.Button(root, text="Новый лабиринт", command=self.new_maze).pack(side=tk.LEFT)

        # Таймер
        self.timer_label = tk.Label(root, text="Время: 0.00 сек")
        self.timer_label.pack()

        self.draw()

    def create_maze(self):
        """Создает лабиринт"""
        self.maze = [[1 for _ in range(self.cols)] for _ in range(self.rows)]
        stack = [(1, 1)]
        self.maze[1][1] = 0

        while stack:
            x, y = stack[-1]
            dirs = [(0, 2), (2, 0), (0, -2), (-2, 0)]
            random.shuffle(dirs)

            for dx, dy in dirs:
                nx, ny = x + dx, y + dy
                if 1 <= nx < self.rows-1 and 1 <= ny < self.cols-1 and self.maze[nx][ny] == 1:
                    self.maze[x + dx//2][y + dy//2] = 0
                    self.maze[nx][ny] = 0
                    stack.append((nx, ny))
                    break
            else:
                stack.pop()

    def create_exits(self):
        """Создает выходы"""
        edges = []
        for x in range(1, self.cols-1):
            if self.maze[1][x] == 0: edges.append((0, x))
            if self.maze[self.rows-2][x] == 0: edges.append((self.rows-1, x))

        for y in range(1, self.rows-1):
            if self.maze[y][1] == 0: edges.append((y, 0))
            if self.maze[y][self.cols-2] == 0: edges.append((y, self.cols-1))

        if edges:
            self.exits = random.sample(edges, min(2, len(edges)))
            for y, x in self.exits:
                self.maze[y][x] = 0

    def draw(self):
        """Рисует лабиринт"""
        self.canvas.delete("all")

        for y in range(self.rows):
            for x in range(self.cols):
                x1 = x * self.cell
                y1 = y * self.cell
                x2 = x1 + self.cell
                y2 = y1 + self.cell

                if (y, x) in self.exits:
                    self.canvas.create_rectangle(x1, y1, x2, y2, fill='green')
                elif self.maze[y][x] == 1:
                    self.canvas.create_rectangle(x1, y1, x2, y2, fill='gray')
                elif (y, x) in self.visited:
                    self.canvas.create_rectangle(x1, y1, x2, y2, fill='lightblue')
                else:
                    self.canvas.create_rectangle(x1, y1, x2, y2, fill='white')

        # Рисуем дерево
        for child, parent in self.parent.items():
            y1, x1 = parent
            y2, x2 = child
            self.canvas.create_line(
                x1*self.cell + self.cell//2,
                y1*self.cell + self.cell//2,
                x2*self.cell + self.cell//2,
                y2*self.cell + self.cell//2,
                width=1, fill='orange'
            )

        # Рисуем паука
        y, x = self.spider
        self.canvas.create_oval(
            x*self.cell + 5, y*self.cell + 5,
            (x+1)*self.cell - 5, (y+1)*self.cell - 5,
            fill='black'
        )

    def start(self):
        """Запускает поиск"""
        if self.running: return
        self.running = True
        self.start_time = time.time()
        self.visited = set([self.spider])
        self.queue = [self.spider]
        self.parent = {}
        self.search()

    def search(self):
        """Автоматический поиск"""
        if not self.running or not self.queue:
            return

        current = self.queue.pop(0)
        y, x = current
        self.spider = current

        # Нашли выход
        if current in self.exits:
            self.show_path(current)
            self.running = False
            elapsed = time.time() - self.start_time
            self.timer_label.config(text=f"Время: {elapsed:.2f} сек")
            return

        # Ищем соседей
        for dy, dx in [(0,1), (1,0), (0,-1), (-1,0)]:
            ny, nx = y + dy, x + dx
            if 0 <= ny < self.rows and 0 <= nx < self.cols:
                if (self.maze[ny][nx] == 0 or (ny,nx) in self.exits) and (ny,nx) not in self.visited:
                    self.visited.add((ny,nx))
                    self.queue.append((ny,nx))
                    self.parent[(ny,nx)] = current

        # Обновляем таймер
        elapsed = time.time() - self.start_time
        self.timer_label.config(text=f"Время: {elapsed:.2f} сек")

        self.draw()

        # Продолжаем поиск
        self.root.after(100, self.search)

    def show_path(self, exit_pos):
        """Показывает путь"""
        path = []
        node = exit_pos
        while node in self.parent:
            path.append(node)
            node = self.parent[node]
        path.append(self.spider)

        for i in range(len(path)-1):
            y1, x1 = path[i]
            y2, x2 = path[i+1]
            self.canvas.create_line(
                x1*self.cell + self.cell//2,
                y1*self.cell + self.cell//2,
                x2*self.cell + self.cell//2,
                y2*self.cell + self.cell//2,
                width=3, fill='red'
            )

    def new_maze(self):
        """Новый лабиринт"""
        self.running = False
        self.create_maze()
        self.spider = (1, 1)
        self.create_exits()
        self.visited = set([self.spider])
        self.queue = []
        self.parent = {}
        self.timer_label.config(text="Время: 0.00 сек")
        self.draw()

if __name__ == "__main__":
    root = tk.Tk()
    SpiderMaze(root)
    root.mainloop()
